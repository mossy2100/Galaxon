<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Galaxon.Core</name>
    </assembly>
    <members>
        <member name="T:Galaxon.Core.Collections.CollectionExtensions">
            <summary>
            Extension methods for ICollection and ICollection{T}.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Collections.CollectionExtensions.IsEmpty(System.Collections.ICollection)">
            <summary>
            Check if an ICollection (array, list, etc.) is null or empty.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Collections.DictionaryExtensions">
            <summary>
            Extension methods for Dictionary.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Collections.DictionaryExtensions.HasUniqueValues``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Checks if a dictionary contains unique values.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <param name="dict">The dictionary to check.</param>
            <returns>True if the dictionary contains unique values; otherwise, false.</returns>
            <remarks>
            This method utilizes LINQ's All method to efficiently check if all values in the dictionary
            are unique. It uses a HashSet to track unique values.
            </remarks>
        </member>
        <member name="M:Galaxon.Core.Collections.DictionaryExtensions.Flip``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Create a new dictionary from the instance with keys and values flipped.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <param name="dict">The dictionary to flip.</param>
            <returns>The flipped dictionary.</returns>
            <exception cref="T:Galaxon.Core.Exceptions.ArgumentInvalidException">
            If the instance contains duplicate values.
            </exception>
        </member>
        <member name="T:Galaxon.Core.Collections.EnumerableExtensions">
            <summary>
            Extension methods for IEnumerable and IEnumerable{T}.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Collections.EnumerableExtensions.Diff``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Return values from one collection with values from a second collection removed.
            This method supports duplicates, so this is not the same as set difference.
            For example, if list1 has two instances of "cat" and list2 has one instance of "cat", the
            result will have one instance of "cat".
            </summary>
        </member>
        <member name="M:Galaxon.Core.Collections.EnumerableExtensions.ToIndex``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts an IEnumerable of objects with an Id property to a Dictionary{int, T},
            using the value of the Id property as the key.
            </summary>
            <typeparam name="T">The type of objects in the IEnumerable.</typeparam>
            <param name="items">The IEnumerable of objects.</param>
            <returns>
            A Dictionary{int, T} with the Id property values as keys and the objects as values.
            </returns>
        </member>
        <member name="T:Galaxon.Core.Exceptions.ArgumentFormatException">
            <summary>
            This exception type is useful for an ArgumentException that is also a FormatException.
            The usual FormatException is probably best reserved for situations not involving method
            parameters, e.g. parsing a file.
            I'm using the same parameter order here as used by ArgumentNullException and
            ArgumentOutOfRangeException.
            i.e. (paramName, message), for consistency. The base class, ArgumentException,
            has the parameters in a different order, i.e. (message, paramName), which can be confusing.
            For this reason, I've resolved not to use ArgumentException anymore but to treat it as an
            abstract base class.
            This will avoid the issue with the arguments being out of order, and the lack of specificity.
            Normally for any ArgumentException we want to identify the argument causing the exception (which
            should be done using nameof()), unless there are several, in which case the offending arguments
            can be identified in the message.
            </summary>
            <see cref="T:System.ArgumentException"/>
            <see cref="T:System.ArgumentNullException"/>
            <see cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:Galaxon.Core.Exceptions.ArgumentFormatException.#ctor">
            <summary>
            Initializes a new instance of the ArgumentFormatException class.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Exceptions.ArgumentFormatException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the ArgumentFormatException class with an error message, and
            (optionally) a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Galaxon.Core.Exceptions.ArgumentFormatException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the ArgumentFormatException class with the parameter name, an
            error message, and (optionally) a reference to the inner exception that is the cause of this
            exception.
            </summary>
            <param name="paramName">The parameter name.</param>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Galaxon.Core.Exceptions.ArgumentInvalidException">
            <summary>
            This exception type is useful for an ArgumentException when the argument is invalid for a
            reason other than being null, out of range, or having an invalid format.
            I'm using the same parameter order here as used by ArgumentNullException and
            ArgumentOutOfRangeException, i.e. (paramName, message), for consistency. The base class,
            ArgumentException, has the parameters in a different order, i.e. (message, paramName), which can
            be confusing.
            I've resolved not to use ArgumentException anymore but to treat it as an abstract base class.
            This will avoid the issue with the arguments being out of order, and the lack of specificity.
            Normally for any ArgumentException we want to identify the argument causing the exception (which
            should be done using nameof()), unless there are several, in which case the offending arguments
            can be identified in the message.
            </summary>
            <see cref="T:System.ArgumentException"/>
            <see cref="T:System.ArgumentNullException"/>
            <see cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:Galaxon.Core.Exceptions.ArgumentInvalidException.#ctor">
            <summary>
            Initializes a new instance of the ArgumentInvalidException class.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Exceptions.ArgumentInvalidException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the ArgumentInvalidException class with an error message, and
            (optionally) a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Galaxon.Core.Exceptions.ArgumentInvalidException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the ArgumentInvalidException class with the parameter name, an
            error message, and (optionally) a reference to the inner exception that is the cause of this
            exception.
            </summary>
            <param name="paramName">The parameter name.</param>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Galaxon.Core.Exceptions.DataNotFoundException">
            <summary>
            Exception for when an attempt is made to obtain data from a database, but it isn't found.
            It's a bit more specific than DataException, and sometimes ObjectNotFoundException is not
            exactly what is meant.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Exceptions.DataNotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the DataNotFoundException class with an error message
            (optional), and a reference to the inner exception that is the cause of this exception
            (optional).
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:Galaxon.Core.Exceptions.MatchNotFoundException">
            <summary>
            This exception type is similar to ArgumentOutOfRangeException, except intended for use in switch
            statements and expressions, when the value being tested matches none of the patterns.
            It could also be used for when a string doesn't match a regular expression.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Exceptions.MatchNotFoundException.#ctor">
            <summary>
            Initializes a new instance.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Exceptions.MatchNotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance with an error message, and (optionally) a reference to the inner
            exception that is the cause of this exception.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Galaxon.Core.Files.DirectoryUtility">
            <summary>
            Extension methods for the Directory class, and other useful methods for working with
            directories.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Files.DirectoryUtility.GetParentDirectoryByFileType(System.String)">
            <summary>
            Gets the path to the closest ancestor directory to the current (assembly) directory
            (which could be itself) containing a file with the specified extension.
            </summary>
            <returns>
            The path to the directory if found, or <c>null</c>.
            </returns>
        </member>
        <member name="M:Galaxon.Core.Files.DirectoryUtility.GetSolutionDirectory">
            <summary>
            Gets the path to the directory containing the solution file (.sln).
            </summary>
            <returns>
            The path to the solution directory if found, or <c>null</c> if no solution file was found.
            </returns>
        </member>
        <member name="M:Galaxon.Core.Files.DirectoryUtility.GetProjectDirectory">
            <summary>
            Gets the path to the directory containing the project file (.csproj).
            </summary>
            <returns>
            The path to the project directory if found, or <c>null</c> if no project file was found.
            </returns>
        </member>
        <member name="T:Galaxon.Core.Functional.Memoization">
            <summary>
            Enables memoization of pure functions by remembering previous results.
            </summary>
        </member>
        <member name="P:Galaxon.Core.Functional.Memoization.DebugMode">
            <summary>
            Set to true if you want to check if cache is being used to get a result.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Functional.Memoization.Memoize``2(System.Func{``0,``1})">
            <summary>
            Enables caching of the results of unary pure functions.
            </summary>
            <param name="f">The pure function.</param>
            <typeparam name="T">The input type.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <returns>The memoized version of the pure function.</returns>
        </member>
        <member name="M:Galaxon.Core.Functional.Memoization.Memoize``3(System.Func{``0,``1,``2})">
            <summary>
            Enables caching of the results of binary pure functions.
            </summary>
            <param name="f">The pure function.</param>
            <typeparam name="T1">First argument type.</typeparam>
            <typeparam name="T2">Second argument type.</typeparam>
            <typeparam name="TResult">Result type.</typeparam>
            <returns>The memoized version of the pure function.</returns>
        </member>
        <member name="T:Galaxon.Core.Numbers.BigIntegerExtensions">
            <summary>
            Extension methods for BigInteger.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.BigIntegerExtensions.ToUnsigned(System.Numerics.BigInteger)">
            <summary>
            Get the unsigned, twos-complement version of the value, containing the fewest number of
            bytes.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.BigIntegerExtensions.Reverse(System.Numerics.BigInteger)">
            <summary>
            Reverse a BigInteger.
            e.g. 123 becomes 321.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.BigIntegerExtensions.IsPalindromic(System.Numerics.BigInteger)">
            <summary>
            Check if a BigInteger is palindromic.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.BigIntegerExtensions.DigitSum(System.Numerics.BigInteger)">
            <summary>
            Sum of the digits in a BigInteger.
            If present, a negative sign is ignored.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.BigIntegerExtensions.NumDigits(System.Numerics.BigInteger)">
            <summary>
            Get the number of digits in the BigInteger.
            The result will be the same for a positive or negative value.
            I tried doing this with double.Log() but because double is imprecise it gives wrong results
            for values close to but less than powers of 10.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.BigIntegerExtensions.Exp2(System.Int32)">
            <summary>Compute 2 raised to a given integer power.</summary>
            <param name="y">The power to which 2 is raised.</param>
            <returns>2 raised to the given BigInteger value.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.BigIntegerExtensions.Exp10(System.Int32)">
            <summary>Compute 10 raised to a given integer power.</summary>
            <param name="y">The power to which 10 is raised.</param>
            <returns>10 raised to the given BigInteger value.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.BigIntegerExtensions.TruncSqrt(System.Numerics.BigInteger)">
            <summary>
            Calculated the truncated square root of a BigInteger value.
            Uses Newton's method.
            </summary>
            <param name="n">The BigInteger value.</param>
            <returns>The truncated square root.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.BigIntegerExtensions.IsPowerOf2(System.Numerics.BigInteger)">
            <summary>Check if a BigInteger is a power of 2.</summary>
            <param name="bi">The BigInteger to inspect.</param>
            <returns>If the value is a power of 2.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.BigIntegerExtensions._Factorial(System.Numerics.BigInteger)">
            <summary>
            Calculates the factorial of a non-negative integer.
            Private version.
            </summary>
            <param name="n">The non-negative integer for which to calculate the factorial.</param>
            <returns>The factorial of the specified non-negative integer.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">When the argument is negative.</exception>
        </member>
        <member name="F:Galaxon.Core.Numbers.BigIntegerExtensions.Factorial">
            <summary>
            Calculates the factorial of a non-negative integer.
            Public memoized version.
            </summary>
            <returns>The factorial of the specified non-negative integer.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">When the argument is negative.</exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.BigIntegerExtensions.FlooredDivision(System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
            Calculates the floored division of two BigInteger values.
            </summary>
            <param name="dividend">The dividend.</param>
            <param name="divisor">The divisor.</param>
            <returns>The result of the floored division.</returns>
            <exception cref="T:System.DivideByZeroException">Thrown when the divisor is zero.</exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.BigIntegerExtensions.DivMod(System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>
            Return the floored division of 2 BigInteger values, with the remainder after division.
            </summary>
            <param name="dividend"></param>
            <param name="divisor"></param>
            <returns>A tuple containing the result of the floored division, and the remainder.</returns>
            <exception cref="T:System.DivideByZeroException"></exception>
        </member>
        <member name="T:Galaxon.Core.Numbers.BinaryIntegerExtensions">
            <summary>
            Extension methods for IBinaryInteger{T}.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.BinaryIntegerExtensions.SuperscriptChars">
            <summary>
            Map from normal integer characters to their superscript versions.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.BinaryIntegerExtensions.SubscriptChars">
            <summary>
            Map from normal integer characters to their subscript versions.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.BinaryIntegerExtensions.ToSuperscript``1(``0)">
            <summary>
            Render an integer as a superscript string.
            This is useful for formatting exponents, numerators, and other numeric superscripts when
            HTML is unavailable.
            See <see href="https://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts"/>
            See <see href="https://rupertshepherd.info/resource_pages/superscript-letters-in-unicode"/>
            See <see href="https://unicode-table.com/en/"/>
            </summary>
            <param name="n">The integer.</param>
            <returns>The string of superscript characters.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.BinaryIntegerExtensions.ToSubscript``1(``0)">
            <summary>
            Render an integer as a subscript string.
            This is useful for formatting denominators, the number of atoms in a molecule, atomic
            numbers, and other numeric subscripts when HTML is unavailable.
            </summary>
            <param name="n">The integer.</param>
            <returns>The string of subscript characters.</returns>
        </member>
        <member name="T:Galaxon.Core.Numbers.DecimalExtensions">
            <summary>Extension methods for decimal.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.DecimalExtensions.NUM_EXP_BITS">
            <summary>The number of bits in the exponent.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.DecimalExtensions.NUM_INT_BITS">
            <summary>The number of bits in the integer part.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.DecimalExtensions.MAX_SCALE">
            <summary>The minimum scale factor (inverse decimal exponent).</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Disassemble(System.Decimal)">
            <summary>
            Disassemble the decimal into bitwise parts.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.GetScaleBits(System.Decimal)">
            <summary>
            Get the scale bits from a decimal value.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Log(System.Decimal)">
            <summary>
            Calculate the natural logarithm of a decimal.
            The algorithm is from:
            <see href="https://en.wikipedia.org/wiki/Natural_logarithm"/>
            DecimalEx.Log() hangs for very small values, so I made this version, which doesn't.
            It's tested, fast, and doesn't break with the largest or smallest decimal values.
            <see cref="M:System.Math.Log(System.Double)"/>
            </summary>
            <param name="m">A decimal value.</param>
            <returns>The natural logarithm of the given value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If the argument is less than or equal to 0.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Log(System.Decimal,System.Decimal)">
            <summary>
            Logarithm of a decimal in a specified base.
            <see cref="M:System.Math.Log(System.Double,System.Double)"/>
            <see cref="M:Galaxon.Core.Numbers.DecimalExtensions.Log(System.Decimal,System.Decimal)"/>
            </summary>
            <param name="m">The decimal value.</param>
            <param name="b">The base.</param>
            <returns>The logarithm of z in base b.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If the number is less
            than or equal to 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If the base is less than
            or equal to 0, or equal to 1.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Log10(System.Decimal)">
            <summary>
            Logarithm of a decimal in base 10.
            <see cref="M:System.Math.Log10(System.Double)"/>
            <see cref="M:Galaxon.Core.Numbers.DecimalExtensions.Log10(System.Decimal)"/>
            </summary>
            <param name="m">The decimal value.</param>
            <returns>The logarithm of the number in base 10.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If the number is less than or equal to 0.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Exp10(System.Decimal)">
            <summary>
            Calculate 10 raised to a decimal power.
            </summary>
            <param name="m">A decimal value.</param>
            <returns>10^d</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Log2(System.Decimal)">
            <summary>
            Logarithm of a decimal in base 2.
            </summary>
            <param name="m">The decimal value.</param>
            <returns>The logarithm of the number in base 2.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If the number is less than or equal to 0.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Exp2(System.Decimal)">
            <summary>
            Calculate 2 raised to a decimal power.
            </summary>
            <param name="m">A decimal value.</param>
            <returns>2^d</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Sinh(System.Decimal)">
            <summary>
            Hyperbolic sine.
            </summary>
            <param name="x">The hyperbolic angle.</param>
            <returns>The hyperbolic sine of the given angle.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Cosh(System.Decimal)">
            <summary>
            Hyperbolic cosine.
            </summary>
            <param name="x">The hyperbolic angle.</param>
            <returns>The hyperbolic cosine of the given angle.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Tanh(System.Decimal)">
            <summary>
            Hyperbolic tangent.
            </summary>
            <param name="x">The hyperbolic angle.</param>
            <returns>The hyperbolic tangent of the given angle.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Asinh(System.Decimal)">
            <summary>
            Inverse hyperbolic sine.
            </summary>
            <param name="x">The hyperbolic sine of an angle.</param>
            <returns>The angle.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Acosh(System.Decimal)">
            <summary>
            Inverse hyperbolic cosine.
            </summary>
            <param name="x">The hyperbolic cosine of an angle.</param>
            <returns>The angle.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Atanh(System.Decimal)">
            <summary>
            Inverse hyperbolic tangent.
            </summary>
            <param name="x">The hyperbolic tangent of an angle.</param>
            <returns>The angle.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.RoundSigFigs(System.Decimal,System.Int32)">
            <summary>
            Round off a value to a given number of significant figures.
            </summary>
            <param name="m">The number to round.</param>
            <param name="n">The number of significant figures.</param>
            <returns>The rounded number.</returns>
            TODO: Test. If digits is too high an exception will be thrown, so this needs to be checked.
        </member>
        <member name="M:Galaxon.Core.Numbers.DecimalExtensions.Assemble(System.Byte,System.Byte,System.UInt128)">
            <summary>
            Assemble a new decimal value from bitwise parts.
            </summary>
            <param name="signBit">The sign bit (1 or 0).</param>
            <param name="scaleBits">The scale bits.</param>
            <param name="intBits">The integer bits.</param>
            <returns>The new decimal.</returns>
        </member>
        <member name="T:Galaxon.Core.Numbers.DoubleExtensions">
            <summary>Extension methods and other bonus stuff for double.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.DoubleExtensions.DELTA">
            <summary>
            The default maximum difference between 2 double values being compared for equality.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.DoubleExtensions.TOTAL_NUM_BITS">
            <summary>The total number of bits in the value.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.DoubleExtensions.NUM_FRAC_BITS">
            <summary>The number of bits in the fraction.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.DoubleExtensions.RoundSigFigs(System.Double,System.Int32)">
            <summary>
            Round off a value to a given number of significant figures.
            </summary>
            <param name="d">The number to round.</param>
            <param name="nSigFigs">The number of significant figures.</param>
            <returns>The rounded number.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.DoubleExtensions.Disassemble(System.Double)">
            <summary>
            Disassemble the double into its bitwise components.
            </summary>
            <see href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format"/>
        </member>
        <member name="M:Galaxon.Core.Numbers.DoubleExtensions.Assemble(System.Byte,System.UInt16,System.UInt64)">
            <summary>
            Assemble a new double from parts.
            </summary>
            <param name="signBit">The sign bit (1 or 0).</param>
            <param name="expBits">The exponent bits.</param>
            <param name="fracBits">The fraction bits.</param>
            <returns>The new double.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.DoubleExtensions.IsPositiveInteger(System.Double)">
            <summary>
            Check if a double is a positive integer.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.DoubleExtensions.IsNegativeInteger(System.Double)">
            <summary>
            Check if a double is a negative integer.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.DoubleExtensions.IsPerfectSquare(System.Double)">
            <summary>
            Check if a value is a perfect square.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.DoubleExtensions.FuzzyEquals(System.Double,System.Double,System.Double)">
            <summary>
            Check if 2 double values are equal for practical purposes.
            If two double values differ only by the least significant bit, this is more likely
            due to inaccuracies in floating point representations than actual inequality.
            This code is copied/adapted from Google Guava DoubleMath.fuzzyEquals().
            <see href="https://github.com/google/guava/blob/master/guava/src/com/google/common/math/DoubleMath.java#L360"/>
            I initially tried the algorithm from the Microsoft documentation, it didn't work in all cases.
            <see href="https://learn.microsoft.com/en-us/dotnet/api/system.double.equals?view=net-7.0#system-double-equals(system-double)"/>
            </summary>
            <param name="a">First number.</param>
            <param name="b">Second number.</param>
            <param name="tolerance">The maximum allowable difference between them.</param>
            <returns>If close enough to equal.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.DoubleExtensions.FuzzyEquals(System.Nullable{System.Double},System.Nullable{System.Double},System.Double)">
            <summary>
            Compare two nullable doubles for fuzzy equality.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.DoubleExtensions.FuzzyIsInteger(System.Double,System.Double)">
            <summary>
            IsInteger() can be a bit strict. This method allows for some fuzziness.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.DoubleExtensions.FuzzyIsPositiveInteger(System.Double,System.Double)">
            <summary>
            Check if a double is a positive integer, with some fuzziness.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.DoubleExtensions.FuzzyIsNegativeInteger(System.Double,System.Double)">
            <summary>
            Check if a double is a negative integer, with some fuzziness.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Numbers.EnumerableNumberExtensions">
            <summary>
            LINQ methods for IEnumerable{INumberBase}.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.EnumerableNumberExtensions.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0})">
            <summary>
            Get the sum of all values in the collection, transformed by a function, if provided.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.EnumerableNumberExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0})">
            <summary>
            Get the product of all values in the collection, transformed by a function, if provided.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.EnumerableNumberExtensions.Average``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Given a collection of T values, get the average (i.e. the arithmetic mean).
            </summary>
            <see href="https://en.wikipedia.org/wiki/Arithmetic_mean"/>
        </member>
        <member name="M:Galaxon.Core.Numbers.EnumerableNumberExtensions.GeometricMean``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Given a collection of T numbers, get the geometric mean.
            </summary>
            <see href="https://en.wikipedia.org/wiki/Geometric_mean"/>
        </member>
        <member name="T:Galaxon.Core.Numbers.FloatingPointExtensions">
            <summary>Extension methods for IFloatingPoint{T}.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetExtensionType``1">
            <summary>
            Get the Galaxon extension type for this floating point type.
            </summary>
            <typeparam name="T">The standard floating point type.</typeparam>
            <returns>The corresponding extension type.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetTotalNumBits``1">
            <summary>
            Get the total number of bits in values of this type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetNumFracBits``1">
            <summary>
            Get the number of bits in the fraction part of values of this type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetNumExpBits``1">
            <summary>
            Get the number of bits in the exponent part of values of this type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetExpBias``1">
            <summary>
            Get the exponent bias for this type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetMinExp``1">
            <summary>
            Get the minimum binary exponent supported by the type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetMaxExp``1">
            <summary>
            Get the maximum binary exponent supported by the type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetSignBitMask``1">
            <summary>
            Get the sign bit mask for this type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetExpBitMask``1">
            <summary>
            Get the exponent bit mask for this type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetFracBitMask``1">
            <summary>
            Get the fraction bit mask for this type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetMinPosSubnormalValue``1">
            <summary>
            Get the minimum positive subnormal value for this type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetMaxPosSubnormalValue``1">
            <summary>
            Get the maximum positive subnormal value for this type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetMinPosNormalValue``1">
            <summary>
            Get the minimum positive normal value for this type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetMaxPosNormalValue``1">
            <summary>
            Get the minimum positive subnormal value for this type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetNegativeInfinity``1">
            <summary>
            Get the negative infinity value for a standard binary floating point type.
            </summary>
            <typeparam name="T">The standard binary floating point type.</typeparam>
            <returns>The value of the NegativeInfinity property.</returns>
            <exception cref="T:System.MissingMemberException">
            If the class doesn't have a static field or property names "NegativeInfinity".
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetPositiveInfinity``1">
            <summary>
            Get the positive infinity value for a standard binary floating point type.
            </summary>
            <typeparam name="T">The standard binary floating point type.</typeparam>
            <returns>The value of the PositiveInfinity property.</returns>
            <exception cref="T:System.MissingMemberException">
            If the class doesn't have a static field or property names "PositiveInfinity".
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetInfinities``1">
            <summary>
            Get the positive and negative infinity values for a standard binary floating point type.
            </summary>
            <typeparam name="T">The standard binary floating point type.</typeparam>
            <returns>
            The value of the NegativeInfinity and PositiveInfinity fields or properties.
            </returns>
            <exception cref="T:System.MissingMemberException">
            If the class doesn't have static fields or properties called "NegativeInfinity" and
            "PositiveInfinity".
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.Disassemble``1(``0)">
            <summary>
            Disassemble the floating point value into its bitwise components.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.GetExpBits``1(``0)">
            <summary>Get the exponent bits from a floating point number.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.FloatingPointExtensions.Assemble``1(System.Byte,System.UInt16,System.UInt64)">
            <summary>
            Assemble a new floating point value from parts.
            </summary>
            <param name="signBit">The sign bit (1 or 0).</param>
            <param name="expBits">The exponent bits.</param>
            <param name="fracBits">The fraction bits.</param>
            <typeparam name="T">A floating point type.</typeparam>
            <returns>The new floating point value.</returns>
            <exception cref="T:System.InvalidOperationException">If the type is unsupported.</exception>
        </member>
        <member name="T:Galaxon.Core.Numbers.HalfExtensions">
            <summary>Extension methods and other bonus stuff for Half.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.HalfExtensions.TOTAL_NUM_BITS">
            <summary>The total number of bits in the value.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.HalfExtensions.NUM_FRAC_BITS">
            <summary>The number of bits in the fraction.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.HalfExtensions.Disassemble(System.Half)">
            <summary>
            Disassemble the Half into its bitwise components.
            </summary>
            <see href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format"/>
        </member>
        <member name="M:Galaxon.Core.Numbers.HalfExtensions.Assemble(System.Byte,System.UInt16,System.UInt64)">
            <summary>
            Assemble a new Half from parts.
            </summary>
            <param name="signBit">The sign bit (1 or 0).</param>
            <param name="expBits">The exponent bits.</param>
            <param name="fracBits">The fraction bits.</param>
            <returns>The new Half.</returns>
        </member>
        <member name="T:Galaxon.Core.Numbers.Int16Extensions">
            <summary>Extension methods for short.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.Int16Extensions.Abs(System.Int16)">
            <summary>
            Return the absolute value of a short as a ushort.
            This addresses an issue with short.Abs(), which is that Abs(short.MinValue) can't be expressed
            as a short, and so wrap-around occurs.
            Unsigned integer types don't have an Abs() method, so there's no collision.
            </summary>
            <param name="n">A short value.</param>
            <returns>The absolute value as a ushort.</returns>
        </member>
        <member name="T:Galaxon.Core.Numbers.Int32Extensions">
            <summary>Extension methods for int.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.Int32Extensions.Sqrt(System.Int32)">
            <summary>
            Get the int closest to the square root of the given int.
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.Int32Extensions.Abs(System.Int32)">
            <summary>
            Return the absolute value of an int as a uint.
            This addresses an issue with int.Abs(), which is that Abs(int.MinValue) can't be expressed
            as a int, and so wrap-around occurs.
            Unsigned integer types don't have an Abs() method, so there's no collision.
            </summary>
            <param name="n">A int value.</param>
            <returns>The absolute value as a uint.</returns>
        </member>
        <member name="T:Galaxon.Core.Numbers.Int64Extensions">
            <summary>Extension methods for long.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.Int64Extensions.Pow(System.Int64,System.Int64)">
            <summary>
            Get the long value closest to x^y.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.Int64Extensions.Sqrt(System.Int64)">
            <summary>
            Get the long value closest to âˆšx.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.Int64Extensions.Abs(System.Int64)">
            <summary>
            Return the absolute value of a long as a ulong.
            This addresses an issue with long.Abs(), which is that Abs(long.MinValue) can't be expressed
            as a long, and so wrap-around occurs.
            Unsigned integer types don't have an Abs() method, so there's no collision.
            </summary>
            <param name="n">A long value.</param>
            <returns>The absolute value as a ulong.</returns>
        </member>
        <member name="T:Galaxon.Core.Numbers.NumberExtensions">
            <summary>Extension methods for numbers (INumber{T} and INumberBase{T}).</summary>
            <remarks>
            TODO: Sort out methods to check for implementation of generic interfaces.
            </remarks>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.IsStandardNumberType(System.Type)">
            <summary>
            Check if a type is a standard numerical type in .NET.
            Excludes char, vector, and matrix types.
            </summary>
            <param name="type">The type to check.</param>
            <returns>True if the type is a standard numerical type.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.IsNumberType(System.Type)">
            <summary>
            Check if a type is a number type.
            </summary>
            <param name="type">Some type.</param>
            <returns>If the type implements INumberBase{TSelf}.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.IsSignedNumberType(System.Type)">
            <summary>
            Check if a type is a signed number type.
            </summary>
            <param name="type">Some type.</param>
            <returns>If the type implements ISignedNumber{TSelf}.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.IsUnsignedNumberType(System.Type)">
            <summary>
            Check if a type is an unsigned number type.
            </summary>
            <param name="type">Some type.</param>
            <returns>If the type implements IUnsignedNumber{TSelf}.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.IsIntegerType(System.Type)">
            <summary>
            Check if a type is an integer type.
            </summary>
            <param name="type">Some type.</param>
            <returns>If the type implements IBinaryInteger{TSelf}.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.IsFloatingPointType(System.Type)">
            <summary>
            Check if a type is a floating point type.
            </summary>
            <param name="type">Some type.</param>
            <returns>If the type implements IFloatingPoint{TSelf}.</returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.IsSignedIntegerType(System.Type)">
            <summary>
            Check if a type is a signed integer type.
            </summary>
            <param name="type">Some type.</param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.IsUnsignedIntegerType(System.Type)">
            <summary>
            Check if a type is an unsigned integer type.
            </summary>
            <param name="type">Some type.</param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.IsRealNumberType(System.Type)">
            <summary>
            Check if a type is a real (non-complex) number type.
            </summary>
            <param name="type">Some type.</param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.IsComplexNumberType(System.Type)">
            <summary>
            Check if a type is a complex number type.
            TODO Make it support BigComplex without actually referencing it.
            </summary>
            <param name="type">Some type.</param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.Mod``1(``0,``0)">
            <summary>
            Corrected modulo operation, using floored division.
            The modulus will always have the same sign as the divisor.
            Unlike the truncated division and modulo provided by C#'s operators, floored division
            produces a regular cycling pattern through both negative and positive values of the divisor.
            It permits things like:
            bool isOdd = Modulo(num, 2) == 1;
            Trying to do this using the % operator will fail for negative divisors, however. e.g.
            bool isOdd = num % 2 == 1;
            In this case, if num is negative 0, num % 2 == -1
            </summary>
            <see href="https://en.wikipedia.org/wiki/Modulo_operation"/>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.GetStaticValue``1(System.String)">
            <summary>
            Get the value of the static field or property for a specified number type.
            </summary>
            <typeparam name="T">The number type.</typeparam>
            <param name="name">The name of the static field or property.</param>
            <returns>The value of the specified field or property.</returns>
            <exception cref="T:System.MissingMemberException">
            If the class doesn't have a static field or property with the given name.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.GetMinValue``1">
            <summary>
            Get the min value for a specified number type, if specified.
            </summary>
            <typeparam name="T">The number type.</typeparam>
            <returns>The value of the MinValue property.</returns>
            <exception cref="T:System.MissingMemberException">
            If the class doesn't have a static field or property names "MinValue".
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.GetMaxValue``1">
            <summary>
            Get the maximum value for a specified number type, if specified.
            </summary>
            <typeparam name="T">The number type.</typeparam>
            <returns>The value of the MaxValue property.</returns>
            <exception cref="T:System.MissingMemberException">
            If the class doesn't have a static field or property names "MaxValue".
            </exception>
        </member>
        <member name="M:Galaxon.Core.Numbers.NumberExtensions.GetRange``1">
            <summary>
            Get the minimum and maximum values for a specified number type.
            </summary>
            <typeparam name="T">The number type.</typeparam>
            <returns>The value of the MinValue and MaxValue fields ot properties.</returns>
            <exception cref="T:System.MissingMemberException">
            If the class doesn't have static fields or properties called "MinValue" and "MaxValue".
            </exception>
        </member>
        <member name="T:Galaxon.Core.Numbers.RandomExtensions">
            <summary>
            Extension methods for Random class.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.RandomExtensions.GetShort(System.Random)">
            <summary>
            Get a random signed short.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.RandomExtensions.GetUshort(System.Random)">
            <summary>
            Get a random unsigned short.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.RandomExtensions.GetInt(System.Random)">
            <summary>
            Get a random signed int.
            The Random.Next() method will only return an int in the range 0..int.MaxValue. This method
            will return a signed int with a value anywhere in the valid range for that type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.RandomExtensions.GetUint(System.Random)">
            <summary>
            Get a random unsigned int.
            The Random.Next() method will only return an int in the range 0..int.MaxValue. This method
            will return an unsigned int with a value anywhere in the valid range for that type.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.RandomExtensions.GetLong(System.Random)">
            <summary>
            Get a random signed long.
            Will return a value in the valid range for long (long.MinValue..long.MaxValue).
            The built in NextInt64 method is restricted to non-negative values:
            <see cref="M:System.Random.NextInt64"/>
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.RandomExtensions.GetUlong(System.Random)">
            <summary>
            Get a random unsigned long.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.RandomExtensions.GetHalf(System.Random)">
            <summary>
            Get a random Half.
            Will not return anything weird like -0, Â±âˆž, or NaN.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.RandomExtensions.GetFloat(System.Random)">
            <summary>
            Get a random float.
            Will not return anything weird like -0, Â±âˆž, or NaN.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.RandomExtensions.GetDouble(System.Random)">
            <summary>
            Get a random double.
            Will not return anything weird like -0, Â±âˆž, or NaN.
            The built-in Random.NextDouble() method will only return values in the range 0.0..1.0.
            <see cref="M:System.Random.NextDouble"/>
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.RandomExtensions.GetDecimal(System.Random)">
            <summary>
            Get a random decimal.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.RandomExtensions.DieRoll(System.Random,System.Int32)">
            <summary>
            Simulate rolling a dice with a given number of sides.
            This is designed for board games.
            Using DnD notation, if you want to roll, say, 1d20, call <code>rnd.DieRoll(20)</code>
            </summary>
            <param name="rnd">The Random object.</param>
            <param name="sides">The number of sides on the dice.</param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Numbers.RandomExtensions.DiceRoll(System.Random,System.Int32,System.Int32)">
            <summary>
            Simulate rolling multiple dice with the same number of sides.
            This is designed for board games.
            Using DnD notation, if you want to roll, say, 3d6, call <code>rnd.DiceRoll(3, 6)</code>
            </summary>
            <param name="rnd">The Random object.</param>
            <param name="nDice">The number of dice to roll.</param>
            <param name="sides">The number of sides on the dice.</param>
            <returns></returns>
        </member>
        <member name="T:Galaxon.Core.Numbers.SByteExtensions">
            <summary>Extension methods for sbyte.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.SByteExtensions.Abs(System.SByte)">
            <summary>
            Return the absolute value of an sbyte as a byte.
            This addresses an issue with sbyte.Abs(), which is that Abs(sbyte.MinValue) can't be
            expressed as a sbyte, and so wrap-around occurs.
            Unsigned integer types don't have an Abs() method, so there's no collision.
            </summary>
            <param name="n">A sbyte value.</param>
            <returns>The absolute value as a byte.</returns>
        </member>
        <member name="T:Galaxon.Core.Numbers.SingleExtensions">
            <summary>Extension methods and other bonus stuff for float.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.SingleExtensions.TOTAL_NUM_BITS">
            <summary>The total number of bits in the value.</summary>
        </member>
        <member name="F:Galaxon.Core.Numbers.SingleExtensions.NUM_FRAC_BITS">
            <summary>The number of bits in the fraction.</summary>
        </member>
        <member name="M:Galaxon.Core.Numbers.SingleExtensions.Disassemble(System.Single)">
            <summary>
            Disassemble the float into its bitwise components.
            </summary>
            <see href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format"/>
        </member>
        <member name="M:Galaxon.Core.Numbers.SingleExtensions.Assemble(System.Byte,System.UInt16,System.UInt64)">
            <summary>
            Assemble a new float from parts.
            </summary>
            <param name="signBit">The sign bit (1 or 0).</param>
            <param name="expBits">The exponent bits.</param>
            <param name="fracBits">The fraction bits.</param>
            <returns>The new float.</returns>
        </member>
        <member name="T:Galaxon.Core.Strings.EStringCase">
            <summary>
            May extend later with LowerSnake, LowerCamel, UpperSnake, UpperCamel, but I'd prefer to keep it
            simple for now.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Strings.EStringCase.Lower">
            <summary>
            Lower case.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Strings.EStringCase.Upper">
            <summary>
            Upper case.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Strings.EStringCase.UpperFirstLetter">
            <summary>
            Upper case, first letter only.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Strings.EStringCase.Proper">
            <summary>
            Proper case. This is not the same as title case.
            In proper case, every word has the first letter upper case, and other letters lower-case.
            In title case, some short words like articles and prepositions are all lower-case.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Strings.EStringCase.Mixed">
            <summary>
            Mixed case (i.e. none of the above).
            </summary>
        </member>
        <member name="T:Galaxon.Core.Strings.StringBuilderExtensions">
            <summary>
            Extension methods for StringBuilder.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.StringBuilderExtensions.Prepend(System.Text.StringBuilder,System.Object)">
            <summary>
            Prepends a StringBuilder with a string.
            Reflects Append().
            </summary>
        </member>
        <member name="T:Galaxon.Core.Strings.StringExtensions">
            <summary>
            Extension methods for String.
            </summary>
        </member>
        <member name="F:Galaxon.Core.Strings.StringExtensions.SmallCapsChars">
            <summary>
            Map from lower-case letters to their Unicode small caps equivalents.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.EqualsIgnoreCase(System.String,System.String)">
            <summary>
            See if 2 strings are equal, ignoring case.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.ReplaceChars(System.String,System.Collections.Generic.Dictionary{System.Char,System.String},System.Boolean)">
            <summary>
            Replace characters in a string with other characters by using a character map.
            Example use cases:
            * making a string upper- or lower-case
            * converting lowercase characters to small caps
            * making a string superscript or subscript
            * transliteration/removal of diacritics
            </summary>
            <param name="str">The original string.</param>
            <param name="charMap">The character map.</param>
            <param name="keepCharsNotInMap">
            If a character is encountered that is not in the character
            map, either keep it (true) or skip it (false).
            </param>
            <returns>The transformed string.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.Repeat(System.String,System.Int32)">
            <summary>
            Construct a new string by repeating a string multiple times.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.Reverse(System.String)">
            <summary>
            Reverse a string.
            e.g. "You are awesome." becomes ".emosewa era uoY".
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.IsPalindrome(System.String)">
            <summary>
            Check if a string is a palindrome.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.StripWhitespace(System.String)">
            <summary>
            Remove whitespace from a string.
            </summary>
            <see href="https://www.compart.com/en/unicode/category/Zs"/>
            <param name="str">The string to process.</param>
            <returns>The string with whitespace characters removed.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.StripBrackets(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Remove brackets (and whatever's between them) from a string.
            </summary>
            <param name="str">The string to process.</param>
            <param name="round">If round brackets should be removed.</param>
            <param name="square">If square brackets should be removed</param>
            <param name="curly">If curly brackets should be removed</param>
            <param name="angle">If angle brackets should be removed</param>
            <returns>The string with brackets removed.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.StripTags(System.String)">
            <summary>Strip HTML tags from a string.</summary>
            <param name="str">The string to process.</param>
            <returns>The string with HTML tags removed.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.IsAscii(System.String)">
            <summary>
            Check if a string contains only ASCII characters.
            </summary>
            <param name="str">The string to check.</param>
            <returns></returns>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.ToSmallCaps(System.String)">
            <summary>
            Convert all lower-case letters in a string to their Unicode small caps variant.
            Only works for English letters, so, if necessary (e.g. if the string is in a different
            language), you may wish to call AnyAscii.Transliterate() on the string first.
            </summary>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.ToProper(System.String)">
            <summary>
            Return the string with the first letter of each word upper-case, and all the other letters
            in each word unchanged.
            Words are taken to be sequences of letters and apostrophes (two kinds are supported), and
            are thus separated by 1 or more non-word characters.
            </summary>
            <param name="str">The original string.</param>
            <returns>The string with the first letter of each word upper-cased.</returns>
            <remarks>
            A method ToTitle() could be developed based on this one, but it would require extracting the
            words first, then seeing which ones should be all lower-case (a, an, for, to, etc.) and
            which should have the first letter upper-cased.
            </remarks>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.GetCase(System.String)">
            <summary>
            Get the string's case.
            If it could not be detected, defaults to Mixed.
            </summary>
            <param name="str">Source string.</param>
            <returns>The string's case.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.SetCase(System.String,Galaxon.Core.Strings.EStringCase)">
            <summary>
            Generates a new string from a source string and a desired string case.
            </summary>
            <param name="str">Source string.</param>
            <param name="stringCase">The string case to convert to.</param>
            <returns>The new string.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.ToUpperFirstLetter(System.String)">
            <summary>
            Return the string with the first letter converted to upper-case.
            The other letters aren't changed.
            </summary>
            <param name="str">The original string.</param>
            <returns>The string with the first letter upper-cased.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.ZeroPad(System.String,System.Int32)">
            <summary>
            Pad a string on the left with 0s to make it up to a certain width.
            </summary>
            <param name="str">The string.</param>
            <param name="width">The minimum number of characters in the the result.</param>
            <returns>The zero-padded string.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.GroupDigits(System.String,System.Char,System.Byte)">
            <summary>
            Given a string of digits, format in groups using the specified group separator and group
            size.
            This method is designed for formatting numbers but it could be used for other purposes,
            since the method doesn't check if the characters are actually digits. It just assumes they
            are. Apart from saving time, it allows the method to be used for hexadecimal or other bases.
            Grouping starts from the right. Here's how you would format an integer:
            "12345678".GroupDigits(',', 3) => "12,345,678"
            You can chain methods if you need to, e.g.
            "11111000000001010101".ZeroPad(24).GroupDigits('_', 8) => "00001111_10000000_01010101"
            123456789.ToHex().ZeroPad(8).GroupDigits(' ') => "075b cd15"
            </summary>
            <param name="str">The string, nominally of digits, but can be whatever.</param>
            <param name="separator">The group separator character.</param>
            <param name="size">The group size.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.MakeDigitsSuperscript(System.String)">
            <summary>
            Transform any digit characters in the string to their superscript version.
            </summary>
            <param name="str">The input string.</param>
            <returns>The input string with digits converted to superscript.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.MakeDigitsSubscript(System.String)">
            <summary>
            Transform any digit characters in the string to their subscript version.
            </summary>
            <param name="str">The input string.</param>
            <returns>The input string with digits converted to subscript.</returns>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.ToInt(System.String)">
            <summary>
            Convert nullable string to nullable int without throwing.
            If the string cannot be parsed into an int, return null.
            Of course, TryParse() can be used, but this method is a bit more concise, and saves time
            thinking about nulls.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.ToDouble(System.String)">
            <summary>
            Convert nullable string to nullable double without throwing.
            If the string cannot be parsed into a double, return null.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Strings.StringExtensions.ToDecimal(System.String)">
            <summary>
            Convert nullable string to nullable decimal without throwing.
            If the string cannot be parsed into a decimal, return null.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Testing.AssertExtensions">
            <summary>
            Container for my own custom Assert methods.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Testing.AssertExtensions.AreEqual(System.ValueTuple{System.Double,System.Double,System.Double},System.ValueTuple{System.Double,System.Double,System.Double},System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>
            Helper function to compare DMS (degrees, minutes, seconds) tuples for equality.
            </summary>
            <param name="a">Angle 1</param>
            <param name="b">Angle 2</param>
            <param name="delta">Maximum acceptable difference between the two angles.</param>
        </member>
        <member name="M:Galaxon.Core.Testing.AssertExtensions.AreEqual(System.DateTime,System.DateTime,System.Nullable{System.TimeSpan})">
            <summary>
            Helper function to compare DateTimes for equality.
            </summary>
            <param name="dt1">The first DateTime</param>
            <param name="dt2">The second DateTime</param>
            <param name="delta">Maximum acceptable difference.</param>
        </member>
        <member name="M:Galaxon.Core.Testing.AssertExtensions.IsInRange(System.Double,System.Double,System.Double,System.Boolean,System.Boolean)">
            <summary>
            Check if a value is in a given range.
            </summary>
            <param name="value">The value to test.</param>
            <param name="lower">The lower value.</param>
            <param name="upper">The upper value.</param>
            <param name="includeLower">Include lower value in the range.</param>
            <param name="includeUpper">Include upper value in the range.</param>
        </member>
        <member name="M:Galaxon.Core.Testing.AssertExtensions.AreEqual(System.Double,System.Decimal)">
            <summary>
            Helper function to test if a double equals a decimal.
            </summary>
            <param name="expected">Expected double value</param>
            <param name="actual">Actual decimal value</param>
        </member>
        <member name="M:Galaxon.Core.Testing.AssertExtensions.AreEqualPercent(System.Double,System.Double,System.Double)">
            <summary>
            Compare two double values for equality, with the delta expressed as percentage of the
            expected value rather than an absolute value.
            </summary>
        </member>
        <member name="T:Galaxon.Core.Types.EnumExtensions">
            <summary>
            Extension methods for enum types.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Types.EnumExtensions.GetDescription(System.Enum)">
            <summary>
            Get the value of the Description attribute for the enum value, or, if not provided,
            the name of the value (same as ToString()).
            </summary>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Galaxon.Core.Types.EnumExtensions.TryParse``1(System.String,``0@)">
            <summary>
            Similar to Enum.TryParse(), this method finds an enum value given a name or description.
            If no values are found with a matching name, looks for a match on description.
            Must match exactly (case-sensitive) the value name or the Description attribute.
            </summary>
            <param name="nameOrDescription">The enum value's name or description.</param>
            <param name="value">The matching enum value, or default if not found.</param>
            <typeparam name="T">The enum type.</typeparam>
            <returns>If a matching enum value was found.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If the type param is not an enum.
            </exception>
        </member>
        <member name="T:Galaxon.Core.Types.ReflectionExtensions">
            <summary>
            Handy reflection-related methods.
            </summary>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.GetStaticFieldValue``1(System.Type,System.String)">
            <summary>
            Get the value of a static field.
            </summary>
            <param name="classType">The class type.</param>
            <param name="name">The name of the field.</param>
            <typeparam name="TField">The field type.</typeparam>
            <returns>The value of the static field.</returns>
            <exception cref="T:System.MissingMemberException">
            If the static field doesn't exist on the specified type.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.GetStaticFieldValue``2(System.String)">
            <summary>
            Get the value of a static field.
            </summary>
            <param name="name">The name of the field.</param>
            <typeparam name="TClass">The class type.</typeparam>
            <typeparam name="TField">The field type.</typeparam>
            <returns>The value of the static field.</returns>
            <exception cref="T:System.MissingMemberException">
            If the static field doesn't exist on the specified type.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.GetStaticPropertyValue``1(System.Type,System.String)">
            <summary>
            Get the value of a static property.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="classType">The class type.</param>
            <typeparam name="TProperty">The property type.</typeparam>
            <returns>The value of the static property.</returns>
            <exception cref="T:System.MissingMemberException">
            If the static property doesn't exist on the specified type.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.GetStaticPropertyValue``2(System.String)">
            <summary>
            Get the value of a static property.
            </summary>
            <param name="name">The name of the property.</param>
            <typeparam name="TClass">The class type.</typeparam>
            <typeparam name="TProperty">The property type.</typeparam>
            <returns>The value of the static property.</returns>
            <exception cref="T:System.MissingMemberException">
            If the static property doesn't exist on the specified type.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.GetStaticFieldOrPropertyValue``1(System.Type,System.String)">
            <summary>
            Get the value of a static field or property.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="classType">The class type.</param>
            <typeparam name="TMember">The field or property type.</typeparam>
            <returns>The value of the static field or property.</returns>
            <exception cref="T:System.MissingMemberException">
            If the static field or property doesn't exist on the specified type.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.GetStaticFieldOrPropertyValue``2(System.String)">
            <summary>
            Get the value of a static field or property.
            </summary>
            <param name="name">The name of the property.</param>
            <typeparam name="TClass">The class type.</typeparam>
            <typeparam name="TMember">The field or property type.</typeparam>
            <returns>The value of the static field or property.</returns>
            <exception cref="T:System.MissingMemberException">
            If the static field or property doesn't exist on the specified type.
            </exception>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.CanCast(System.Type,System.Type)">
            <summary>
            See if a cast operator exists from one type to another.
            </summary>
            <param name="sourceType">The source type.</param>
            <param name="targetType">The target type.</param>
            <returns>If a cast operator exists.</returns>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.GetCastMethod(System.Type,System.Type)">
            <summary>
            Get the info for a method that casts one type to another.
            </summary>
            <param name="sourceType">The source type.</param>
            <param name="targetType">The target type.</param>
            <returns>The method info.</returns>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.CanCast``2">
            <summary>
            See if a cast operator exists from one type to another.
            </summary>
            <typeparam name="TSource">The source type.</typeparam>
            <typeparam name="TTarget">The target type.</typeparam>
            <returns>If a cast operator exists.</returns>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.Cast``2(``0)">
            <summary>
            Case a value from a source type to a target type.
            </summary>
            <typeparam name="TSource">The source type.</typeparam>
            <typeparam name="TTarget">The target type.</typeparam>
            <param name="src">The source value.</param>
            <returns>The target value.</returns>
            <exception cref="T:System.InvalidCastException">If the cast failed.</exception>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.ImplementsInterface(System.Type,System.Type)">
            <summary>
            Check if a type implements an interface.
            </summary>
            <param name="type">The type.</param>
            <param name="interfaceType">The interface type.</param>
            <returns>True if the specified type implements the specified interface.</returns>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.ImplementsInterface``2">
            <summary>
            Check if a type implements an interface.
            </summary>
            <typeparam name="T">The type.</typeparam>
            <typeparam name="TInterface">The interface type.</typeparam>
            <returns>True if the specified type implements the specified interface.</returns>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.ImplementsGenericInterface(System.Type,System.Type)">
            <summary>
            Check if a type implements a generic interface.
            </summary>
            <param name="type">The type.</param>
            <param name="interfaceType">The generic interface type.</param>
            <returns>True if the specified type implements the specified interface.</returns>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.ImplementsGenericInterface``2">
            <summary>
            Check if a type implements an generic interface.
            </summary>
            <typeparam name="T">The type.</typeparam>
            <typeparam name="TInterface">The generic interface type.</typeparam>
            <returns>True if the specified type implements the specified interface.</returns>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.ImplementsSelfReferencingGenericInterface(System.Type,System.Type)">
            <summary>
            Check if a type implements a self-referencing generic interface
            (e.g. IBinaryInteger{TSelf}).
            Only works if the self-referenced type is the first type parameter.
            </summary>
            <param name="type">The type.</param>
            <param name="interfaceType">The self-referencing generic interface.</param>
            <returns>True if the specified type implements the specified interface.</returns>
        </member>
        <member name="M:Galaxon.Core.Types.ReflectionExtensions.ImplementsSelfReferencingGenericInterface``2">
            <summary>
            Check if a type implements an self-referencing generic interface.
            </summary>
            <typeparam name="T">The type.</typeparam>
            <typeparam name="TInterface">The self-referencing generic interface type.</typeparam>
            <returns>True if the specified type implements the specified interface.</returns>
        </member>
    </members>
</doc>
